# Emulater Rust-8 aka emrust8
 A CHIP-8 virtual Computer emulater made in Rust
TODO DOCs once near completion cycle

# Keyboard
|   |   |   |   |   |
|---|---|---|---|---|
| | 1 | 2 | 3 | C | |
| | 4 | 5 | 6 | D | |
| | 7 | 8 | 9 | E | |
| | A | 0 | B | F | |
|   |   |   |   |   |

# Instruction set

<table><thead><tr><th><strong>Opcode</strong></th><th><strong>Mnemonic</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>00E0</code></td><td><code>CLS</code></td><td>Clears the screen.</td></tr><tr><td><code>00EE</code></td><td><code>RET</code></td><td>Returns from a subroutine.</td></tr><tr><td><code>1NNN</code></td><td><code>JP addr</code></td><td>Jumps to address <code>NNN</code>.</td></tr><tr><td><code>2NNN</code></td><td><code>CALL addr</code></td><td>Calls subroutine at address <code>NNN</code>.</td></tr><tr><td><code>3XNN</code></td><td><code>SE Vx, NN</code></td><td>Skips the next instruction if <code>Vx == NN</code>.</td></tr><tr><td><code>4XNN</code></td><td><code>SNE Vx, NN</code></td><td>Skips the next instruction if <code>Vx != NN</code>.</td></tr><tr><td><code>5XY0</code></td><td><code>SE Vx, Vy</code></td><td>Skips the next instruction if <code>Vx == Vy</code>.</td></tr><tr><td><code>6XNN</code></td><td><code>LD Vx, NN</code></td><td>Loads the value <code>NN</code> into register <code>Vx</code>.</td></tr><tr><td><code>7XNN</code></td><td><code>ADD Vx, NN</code></td><td>Adds the value <code>NN</code> to register <code>Vx</code>.</td></tr><tr><td><code>8XY0</code></td><td><code>LD Vx, Vy</code></td><td>Sets <code>Vx = Vy</code>.</td></tr><tr><td><code>8XY1</code></td><td><code>OR Vx, Vy</code></td><td>Sets <code>Vx = Vx OR Vy</code>.</td></tr><tr><td><code>8XY2</code></td><td><code>AND Vx, Vy</code></td><td>Sets <code>Vx = Vx AND Vy</code>.</td></tr><tr><td><code>8XY3</code></td><td><code>XOR Vx, Vy</code></td><td>Sets <code>Vx = Vx XOR Vy</code>.</td></tr><tr><td><code>8XY4</code></td><td><code>ADD Vx, Vy</code></td><td>Adds <code>Vy</code> to <code>Vx</code>. Sets carry flag <code>VF</code> if there is an overflow.</td></tr><tr><td><code>8XY5</code></td><td><code>SUB Vx, Vy</code></td><td>Subtracts <code>Vy</code> from <code>Vx</code>. Sets carry flag <code>VF</code> if there is no borrow.</td></tr><tr><td><code>8XY6</code></td><td><code>SHR Vx</code></td><td>Shifts <code>Vx</code> right by one bit. Stores the least significant bit in <code>VF</code>.</td></tr><tr><td><code>8XY7</code></td><td><code>SUBN Vx, Vy</code></td><td>Sets <code>Vx = Vy - Vx</code>. Sets carry flag <code>VF</code> if there is no borrow.</td></tr><tr><td><code>8XYE</code></td><td><code>SHL Vx</code></td><td>Shifts <code>Vx</code> left by one bit. Stores the most significant bit in <code>VF</code>.</td></tr><tr><td><code>9XY0</code></td><td><code>SNE Vx, Vy</code></td><td>Skips the next instruction if <code>Vx != Vy</code>.</td></tr><tr><td><code>ANNN</code></td><td><code>LD I, addr</code></td><td>Sets <code>I = NNN</code>. (Loads address <code>NNN</code> into the index register <code>I</code>.)</td></tr><tr><td><code>BNNN</code></td><td><code>JP V0, addr</code></td><td>Jumps to the address <code>NNN + V0</code>.</td></tr><tr><td><code>CXNN</code></td><td><code>RND Vx, NN</code></td><td>Sets <code>Vx = random byte AND NN</code>.</td></tr><tr><td><code>DXYN</code></td><td><code>DRW Vx, Vy, N</code></td><td>Draws an <code>N</code>-byte sprite at memory location <code>I</code> at coordinates (<code>Vx</code>, <code>Vy</code>). Sets collision flag <code>VF</code>.</td></tr><tr><td><code>EX9E</code></td><td><code>SKP Vx</code></td><td>Skips the next instruction if the key with the value of <code>Vx</code> is pressed.</td></tr><tr><td><code>EXA1</code></td><td><code>SKNP Vx</code></td><td>Skips the next instruction if the key with the value of <code>Vx</code> is not pressed.</td></tr><tr><td><code>FX07</code></td><td><code>LD Vx, DT</code></td><td>Sets <code>Vx = delay timer</code>.</td></tr><tr><td><code>FX0A</code></td><td><code>LD Vx, K</code></td><td>Waits for a key press and stores the result in <code>Vx</code>.</td></tr><tr><td><code>FX15</code></td><td><code>LD DT, Vx</code></td><td>Sets the delay timer to <code>Vx</code>.</td></tr><tr><td><code>FX18</code></td><td><code>LD ST, Vx</code></td><td>Sets the sound timer to <code>Vx</code>.</td></tr><tr><td><code>FX1E</code></td><td><code>ADD I, Vx</code></td><td>Adds <code>Vx</code> to <code>I</code>.</td></tr><tr><td><code>FX29</code></td><td><code>LD F, Vx</code></td><td>Sets <code>I = location of sprite for digit </code>Vx`.</td></tr><tr><td><code>FX33</code></td><td><code>LD B, Vx</code></td><td>Stores the binary-coded decimal representation of <code>Vx</code> in memory locations <code>I</code>, <code>I+1</code>, <code>I+2</code>.</td></tr><tr><td><code>FX55</code></td><td><code>LD [I], Vx</code></td><td>Stores registers <code>V0</code> through <code>Vx</code> in memory starting at address <code>I</code>.</td></tr><tr><td><code>FX65</code></td><td><code>LD Vx, [I]</code></td><td>Reads values from memory starting at address <code>I</code> into registers <code>V0</code> through <code>Vx</code>.</td></tr></tbody></table>
